var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/utils/video.ts
import ytdl2 from "@distube/ytdl-core";
import path from "path";
import ffmpeg from "ffmpeg-static";
import cp from "child_process";

// src/utils/parserTitles.ts
var parserTitles = (title) => {
  const regex = /[\\,:,?,|,¿,*,<,>,",/]/g;
  return title.replace(regex, "");
};
var parserTitles_default = parserTitles;

// src/utils/fileExist.ts
import fs from "fs";
var fileExist = (pathname) => fs.existsSync(pathname);
var fileExist_default = fileExist;

// src/utils/agent.ts
import ytdl from "@distube/ytdl-core";
import dotenv from "dotenv";
dotenv.config();
var useAgent = !!process.env.PROXY_URL;
var agent;
if (process.env.PROXY_URL) {
  agent = ytdl.createProxyAgent({ uri: process.env.PROXY_URL });
}

// src/utils/video.ts
function Video(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const videoInfo = yield ytdl2.getInfo(url, {
      agent: useAgent ? agent : void 0
    });
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const audio = ytdl2(url, {
      quality: "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    }).on("error", (error) => {
      console.error(error);
    });
    const video = ytdl2(url, {
      quality: (format == null ? void 0 : format.itag) || "highestvideo"
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    }).on("error", (error) => {
      console.error(error);
    });
    const pathname = path.resolve(process.cwd(), directory, `${fileTitle}.mp4`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = cp.spawn(
          ffmpegPath || ffmpeg,
          [
            "-loglevel",
            "8",
            "-hide_banner",
            "-progress",
            "pipe:3",
            "-i",
            "pipe:4",
            "-i",
            "pipe:5",
            "-map",
            "0:a",
            "-map",
            "1:v",
            "-c:v",
            "copy",
            `${pathname}`
          ],
          {
            windowsHide: true,
            stdio: ["inherit", "inherit", "inherit", "pipe", "pipe", "pipe"]
          }
        );
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
          const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
          const total = (videoTotal + audioTotal) / 2;
          const videoSize = tracker.video.total + tracker.audio.total;
          if (onDownloading)
            onDownloading({ percentage: total, size: videoSize });
        });
        ffmpegProcess.on("close", () => {
          resolve({
            message: `File in ${pathname}`,
            error: false,
            videoInfo,
            pathfile: pathname
          });
        });
        audio.pipe(ffmpegProcess.stdio[4]);
        video.pipe(ffmpegProcess.stdio[5]);
      }
    });
    return promise;
  });
}
var video_default = Video;

// src/utils/audio.ts
import ytdl3 from "@distube/ytdl-core";
import path2 from "path";
import ffmpeg2 from "ffmpeg-static";
import cp2 from "child_process";
import ffmMT from "ffmetadata";
function Audio(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      total: null,
      downloaded: null
    };
    const videoInfo = yield ytdl3.getInfo(url, { agent: useAgent ? agent : void 0 });
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const stream = ytdl3(url, {
      filter: "audioonly",
      quality: (format == null ? void 0 : format.itag) || "highestaudio",
      agent: useAgent ? agent : void 0
    }).on("progress", (_, downloaded, total) => {
      tracker.total = total;
      tracker.downloaded = downloaded;
    });
    const pathname = path2.resolve(process.cwd(), directory, `${fileTitle}.mp3`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = cp2.spawn(ffmpegPath || ffmpeg2, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const percentage = tracker.downloaded / tracker.total * 100;
          const size = tracker.total;
          if (onDownloading) onDownloading({ percentage, size });
        });
        ffmpegProcess.on("close", () => {
          const metadata = {
            artist: videoInfo.videoDetails.author.name,
            title: fileTitle,
            album: videoInfo.videoDetails.author.name
          };
          ffmMT.setFfmpegPath(ffmpegPath || ffmpeg2);
          ffmMT.write(pathname, metadata, (err) => {
            if (err) throw err;
            resolve({
              message: `File in ${pathname}`,
              error: false,
              videoInfo,
              pathfile: pathname
            });
          });
        });
        stream.pipe(ffmpegProcess.stdio[4]);
      }
    });
    return promise;
  });
}
var audio_default = Audio;

// src/utils/createStreamAudio.ts
import ytdl4 from "@distube/ytdl-core";
import { spawn } from "child_process";
import ffmpeg3 from "ffmpeg-static";
function createStreamAudio(options) {
  return __async(this, null, function* () {
    const { url, itag } = options;
    const info = yield ytdl4.getInfo(url);
    const stream = ytdl4(url, {
      filter: "audioonly",
      quality: itag,
      agent: useAgent ? agent : void 0
    });
    const ffmpegProcess = spawn(ffmpeg3, [
      "-i",
      "pipe:0",
      "-f",
      "mp3",
      "-ar",
      "48000",
      "-ac",
      "2",
      "-b:a",
      "192k",
      // Add metadata
      "-metadata",
      `title=${info.videoDetails.title}`,
      "-metadata",
      `artist=${info.videoDetails.author.name}`,
      "-metadata",
      `album=${info.videoDetails.author.name}`,
      "pipe:1"
    ], {
      stdio: ["pipe", "pipe", "ignore"]
    });
    stream.pipe(ffmpegProcess.stdin);
    return ffmpegProcess.stdout;
  });
}

// src/utils/createStreamVideo.ts
import { spawn as spawn2 } from "child_process";
import ytdl5 from "@distube/ytdl-core";
import ffmpeg4 from "ffmpeg-static";
function createStreamVideo(options) {
  return __async(this, null, function* () {
    const { url, itag } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const audio = ytdl5(url, {
      quality: "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    }).on("error", (e) => console.log(e));
    const video = ytdl5(url, {
      quality: itag
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    }).on("error", (e) => console.log(e));
    const ffmpegProcess = spawn2(
      ffmpeg4,
      [
        "-hide_banner",
        "-progress",
        "pipe:5",
        "-i",
        "pipe:3",
        // Input audio
        "-i",
        "pipe:4",
        // Input video
        "-map",
        "0:a",
        "-map",
        "1:v",
        "-c:v",
        "copy",
        // Códec de video
        "-f",
        "matroska",
        // Formato de salida
        "pipe:1"
        // Salida por pipe
      ],
      {
        windowsHide: true,
        stdio: ["pipe", "pipe", "ignore", "pipe", "pipe", "pipe"]
      }
    );
    audio.pipe(ffmpegProcess.stdio[3]);
    video.pipe(ffmpegProcess.stdio[4]);
    ffmpegProcess.stdio[5].on("data", (chunk) => {
      const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
      const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
      const total = (videoTotal + audioTotal) / 2;
      const videoSize = tracker.video.total + tracker.audio.total;
      const videoSizeMB = videoSize / 1024 / 1024;
      const downloadedMB = (tracker.video.downloaded + tracker.audio.downloaded) / 1024 / 1024;
      console.log(
        `Progress: ${total.toFixed(2)}% - ${downloadedMB.toFixed(
          2
        )}MB/${videoSizeMB.toFixed(2)}MB`
      );
    });
    return ffmpegProcess.stdout;
  });
}

// src/utils/getInfo.ts
import ytdl6 from "@distube/ytdl-core";
var getInfo = (url) => new Promise((resolve, reject) => {
  try {
    ytdl6.getInfo(url, { agent: useAgent ? agent : void 0 }).then((info) => {
      const {
        title,
        author,
        lengthSeconds,
        viewCount,
        likes,
        averageRating,
        thumbnails
      } = info.videoDetails;
      const { formats } = info;
      const formatsAudio = formats.filter((format) => format.hasAudio && !format.hasVideo);
      const formatsVideo = formats.filter((format) => format.hasVideo && !format.hasAudio);
      const infoObj = {
        title,
        author,
        lengthSeconds,
        viewCount,
        likes,
        averageRating,
        thumbnails,
        formats,
        formatsAudio,
        formatsVideo
      };
      resolve(infoObj);
    }).catch((err) => reject(err));
  } catch (e) {
    reject(e);
  }
});
var getInfo_default = getInfo;
export {
  audio_default as Audio,
  video_default as Video,
  createStreamAudio,
  createStreamVideo,
  getInfo_default as getInfo
};
//# sourceMappingURL=index.mjs.map