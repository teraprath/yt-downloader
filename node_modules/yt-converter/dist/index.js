var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Audio: () => audio_default,
  Video: () => video_default,
  createStreamAudio: () => createStreamAudio,
  createStreamVideo: () => createStreamVideo,
  getInfo: () => getInfo_default
});
module.exports = __toCommonJS(index_exports);

// src/utils/video.ts
var import_ytdl_core2 = __toESM(require("@distube/ytdl-core"));
var import_path = __toESM(require("path"));
var import_ffmpeg_static = __toESM(require("ffmpeg-static"));
var import_child_process = __toESM(require("child_process"));

// src/utils/parserTitles.ts
var parserTitles = (title) => {
  const regex = /[\\,:,?,|,¿,*,<,>,",/]/g;
  return title.replace(regex, "");
};
var parserTitles_default = parserTitles;

// src/utils/fileExist.ts
var import_fs = __toESM(require("fs"));
var fileExist = (pathname) => import_fs.default.existsSync(pathname);
var fileExist_default = fileExist;

// src/utils/agent.ts
var import_ytdl_core = __toESM(require("@distube/ytdl-core"));
var import_dotenv = __toESM(require("dotenv"));
import_dotenv.default.config();
var useAgent = !!process.env.PROXY_URL;
var agent;
if (process.env.PROXY_URL) {
  agent = import_ytdl_core.default.createProxyAgent({ uri: process.env.PROXY_URL });
}

// src/utils/video.ts
function Video(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const videoInfo = yield import_ytdl_core2.default.getInfo(url, {
      agent: useAgent ? agent : void 0
    });
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const audio = (0, import_ytdl_core2.default)(url, {
      quality: "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    }).on("error", (error) => {
      console.error(error);
    });
    const video = (0, import_ytdl_core2.default)(url, {
      quality: (format == null ? void 0 : format.itag) || "highestvideo"
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    }).on("error", (error) => {
      console.error(error);
    });
    const pathname = import_path.default.resolve(process.cwd(), directory, `${fileTitle}.mp4`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = import_child_process.default.spawn(
          ffmpegPath || import_ffmpeg_static.default,
          [
            "-loglevel",
            "8",
            "-hide_banner",
            "-progress",
            "pipe:3",
            "-i",
            "pipe:4",
            "-i",
            "pipe:5",
            "-map",
            "0:a",
            "-map",
            "1:v",
            "-c:v",
            "copy",
            `${pathname}`
          ],
          {
            windowsHide: true,
            stdio: ["inherit", "inherit", "inherit", "pipe", "pipe", "pipe"]
          }
        );
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
          const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
          const total = (videoTotal + audioTotal) / 2;
          const videoSize = tracker.video.total + tracker.audio.total;
          if (onDownloading)
            onDownloading({ percentage: total, size: videoSize });
        });
        ffmpegProcess.on("close", () => {
          resolve({
            message: `File in ${pathname}`,
            error: false,
            videoInfo,
            pathfile: pathname
          });
        });
        audio.pipe(ffmpegProcess.stdio[4]);
        video.pipe(ffmpegProcess.stdio[5]);
      }
    });
    return promise;
  });
}
var video_default = Video;

// src/utils/audio.ts
var import_ytdl_core3 = __toESM(require("@distube/ytdl-core"));
var import_path2 = __toESM(require("path"));
var import_ffmpeg_static2 = __toESM(require("ffmpeg-static"));
var import_child_process2 = __toESM(require("child_process"));
var import_ffmetadata = __toESM(require("ffmetadata"));
function Audio(options) {
  return __async(this, null, function* () {
    const {
      directory = "./",
      itag,
      url,
      title,
      onDownloading,
      ffmpegPath
    } = options;
    const tracker = {
      total: null,
      downloaded: null
    };
    const videoInfo = yield import_ytdl_core3.default.getInfo(url, { agent: useAgent ? agent : void 0 });
    let format;
    if (itag) {
      format = videoInfo.formats.find((fm) => fm.itag === itag);
    }
    const fileTitle = title || parserTitles_default(videoInfo.videoDetails.title);
    const stream = (0, import_ytdl_core3.default)(url, {
      filter: "audioonly",
      quality: (format == null ? void 0 : format.itag) || "highestaudio",
      agent: useAgent ? agent : void 0
    }).on("progress", (_, downloaded, total) => {
      tracker.total = total;
      tracker.downloaded = downloaded;
    });
    const pathname = import_path2.default.resolve(process.cwd(), directory, `${fileTitle}.mp3`);
    const promise = new Promise((resolve, reject) => {
      if (fileExist_default(pathname)) {
        resolve({
          message: `File already downloaded in ${pathname}`,
          error: false,
          videoInfo,
          pathfile: pathname
        });
      } else {
        const ffmpegProcess = import_child_process2.default.spawn(ffmpegPath || import_ffmpeg_static2.default, [
          "-loglevel",
          "8",
          "-hide_banner",
          "-progress",
          "pipe:3",
          "-i",
          "pipe:4",
          `${pathname}`
        ], {
          windowsHide: true,
          stdio: [
            "inherit",
            "inherit",
            "inherit",
            "pipe",
            "pipe",
            "pipe"
          ]
        });
        if (ffmpegProcess === void 0) {
          reject(new Error("Cannot initialize ffmpeg"));
        }
        ffmpegProcess.stdio[3].on("data", () => {
          const percentage = tracker.downloaded / tracker.total * 100;
          const size = tracker.total;
          if (onDownloading) onDownloading({ percentage, size });
        });
        ffmpegProcess.on("close", () => {
          const metadata = {
            artist: videoInfo.videoDetails.author.name,
            title: fileTitle,
            album: videoInfo.videoDetails.author.name
          };
          import_ffmetadata.default.setFfmpegPath(ffmpegPath || import_ffmpeg_static2.default);
          import_ffmetadata.default.write(pathname, metadata, (err) => {
            if (err) throw err;
            resolve({
              message: `File in ${pathname}`,
              error: false,
              videoInfo,
              pathfile: pathname
            });
          });
        });
        stream.pipe(ffmpegProcess.stdio[4]);
      }
    });
    return promise;
  });
}
var audio_default = Audio;

// src/utils/createStreamAudio.ts
var import_ytdl_core4 = __toESM(require("@distube/ytdl-core"));
var import_child_process3 = require("child_process");
var import_ffmpeg_static3 = __toESM(require("ffmpeg-static"));
function createStreamAudio(options) {
  return __async(this, null, function* () {
    const { url, itag } = options;
    const info = yield import_ytdl_core4.default.getInfo(url);
    const stream = (0, import_ytdl_core4.default)(url, {
      filter: "audioonly",
      quality: itag,
      agent: useAgent ? agent : void 0
    });
    const ffmpegProcess = (0, import_child_process3.spawn)(import_ffmpeg_static3.default, [
      "-i",
      "pipe:0",
      "-f",
      "mp3",
      "-ar",
      "48000",
      "-ac",
      "2",
      "-b:a",
      "192k",
      // Add metadata
      "-metadata",
      `title=${info.videoDetails.title}`,
      "-metadata",
      `artist=${info.videoDetails.author.name}`,
      "-metadata",
      `album=${info.videoDetails.author.name}`,
      "pipe:1"
    ], {
      stdio: ["pipe", "pipe", "ignore"]
    });
    stream.pipe(ffmpegProcess.stdin);
    return ffmpegProcess.stdout;
  });
}

// src/utils/createStreamVideo.ts
var import_child_process4 = require("child_process");
var import_ytdl_core5 = __toESM(require("@distube/ytdl-core"));
var import_ffmpeg_static4 = __toESM(require("ffmpeg-static"));
function createStreamVideo(options) {
  return __async(this, null, function* () {
    const { url, itag } = options;
    const tracker = {
      audio: {
        total: null,
        downloaded: null
      },
      video: {
        total: null,
        downloaded: null
      }
    };
    const audio = (0, import_ytdl_core5.default)(url, {
      quality: "highestaudio"
    }).on("progress", (_, downloaded, total) => {
      tracker.audio = { downloaded, total };
    }).on("error", (e) => console.log(e));
    const video = (0, import_ytdl_core5.default)(url, {
      quality: itag
    }).on("progress", (_, downloaded, total) => {
      tracker.video = { downloaded, total };
    }).on("error", (e) => console.log(e));
    const ffmpegProcess = (0, import_child_process4.spawn)(
      import_ffmpeg_static4.default,
      [
        "-hide_banner",
        "-progress",
        "pipe:5",
        "-i",
        "pipe:3",
        // Input audio
        "-i",
        "pipe:4",
        // Input video
        "-map",
        "0:a",
        "-map",
        "1:v",
        "-c:v",
        "copy",
        // Códec de video
        "-f",
        "matroska",
        // Formato de salida
        "pipe:1"
        // Salida por pipe
      ],
      {
        windowsHide: true,
        stdio: ["pipe", "pipe", "ignore", "pipe", "pipe", "pipe"]
      }
    );
    audio.pipe(ffmpegProcess.stdio[3]);
    video.pipe(ffmpegProcess.stdio[4]);
    ffmpegProcess.stdio[5].on("data", (chunk) => {
      const videoTotal = tracker.video.downloaded / tracker.video.total * 100;
      const audioTotal = tracker.audio.downloaded / tracker.audio.total * 100;
      const total = (videoTotal + audioTotal) / 2;
      const videoSize = tracker.video.total + tracker.audio.total;
      const videoSizeMB = videoSize / 1024 / 1024;
      const downloadedMB = (tracker.video.downloaded + tracker.audio.downloaded) / 1024 / 1024;
      console.log(
        `Progress: ${total.toFixed(2)}% - ${downloadedMB.toFixed(
          2
        )}MB/${videoSizeMB.toFixed(2)}MB`
      );
    });
    return ffmpegProcess.stdout;
  });
}

// src/utils/getInfo.ts
var import_ytdl_core6 = __toESM(require("@distube/ytdl-core"));
var getInfo = (url) => new Promise((resolve, reject) => {
  try {
    import_ytdl_core6.default.getInfo(url, { agent: useAgent ? agent : void 0 }).then((info) => {
      const {
        title,
        author,
        lengthSeconds,
        viewCount,
        likes,
        averageRating,
        thumbnails
      } = info.videoDetails;
      const { formats } = info;
      const formatsAudio = formats.filter((format) => format.hasAudio && !format.hasVideo);
      const formatsVideo = formats.filter((format) => format.hasVideo && !format.hasAudio);
      const infoObj = {
        title,
        author,
        lengthSeconds,
        viewCount,
        likes,
        averageRating,
        thumbnails,
        formats,
        formatsAudio,
        formatsVideo
      };
      resolve(infoObj);
    }).catch((err) => reject(err));
  } catch (e) {
    reject(e);
  }
});
var getInfo_default = getInfo;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Audio,
  Video,
  createStreamAudio,
  createStreamVideo,
  getInfo
});
//# sourceMappingURL=index.js.map